=========================
TCP/IP
=========================

:Author: Gao Peng <funky.gao@gmail.com>
:Description: NA
:Revision: $Id$

.. contents:: Table Of Contents
.. section-numbering::


============
路由器队列经常要临时存储数据包直到它们可以转发出去才开始flush，当路由器队列空间不够时，它们就开始丢弃数据包，导致重传，进而导致重复和乱序传递数据包。

udp: datagram
tcp: segment

UDP在IP基础上增加了2个服务

- 数据校验

  IP的校验只是IP的报头部分

- 端口

TCP在IP的服务上增加了4个服务

- 为segment提供了校验位

  确保到达目的地的数据不会在网络传输时被破坏

- 为每个segment分配一个序列号

  保证有序

- 提供了确认和重传机制

  保证每个segment会到达目的地

- 滑动窗口

  TCP每一方都维护一个recv window，该窗口的范围是将要接收对方的数据的序列号

  超出窗口的带序列号的数据被丢弃

私有IP

- 192.168.0.0 ~ 192.168.255.255

- 172.16.0.0 ~ 172.31.255.255

- 10.0.0.0 ~ 10.255.255.255


TCP
===
是个流协议，没有内在的消息和消息边界概念。

读TCP数据时永远不知道read会返回多少字节

send返回，只是拷贝到TCP协议栈里的send buffer

TCP应答采用的是带时延的ACK， 比如收到数据后先看有没有应用层数据，有的话就一起发出去
没有就等待200ms，仍然没有应用层数据，就单独发ACK


    建立握手需要 1.5 RTT

    Client                      Server
      | SYN(MSS,WIN,SEQ                                     |
      |-----------------------------------------------------|
      |                                                     |
      |-----------------------------------------------------|
      |                                                     |
      |-----------------------------------------------------|


UDP
===
即使在同一台机器上运行C/S，UDP也会发生丢包，这是因为缓冲区空间不足造成的

UDP的报文长度最大可以达到64 kb，但是当报文过大时，稳定性会大大减弱。这是因为当报文过大时会被分割，使得每个分割块（翻译可能有误差，原文是fragmentation）的长度小于MTU，然后分别发送，并在接收方重新组合（reassemble），但是如果其中一个报文丢失，那么其他已收到的报文都无法返回给程序，也就无法得到完整的数据了。 
